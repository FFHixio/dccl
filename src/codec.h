// Copyright 2009-2014 Toby Schneider (https://launchpad.net/~tes)
//                     GobySoft, LLC (2013-)
//                     Massachusetts Institute of Technology (2007-2014)
//                     DCCL Developers Team (https://launchpad.net/~dccl-dev)
//
// This file is part of the Dynamic Compact Control Language Library
// ("DCCL").
//
// DCCL is free software: you can redistribute them and/or modify
// them under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 2.1 of the License, or
// (at your option) any later version.
//
// DCCL is distributed in the hope that they will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with DCCL.  If not, see <http://www.gnu.org/licenses/>.



#ifndef DCCL20091211H
#define DCCL20091211H

#include <string>
#include <set>
#include <map>
#include <ostream>
#include <stdexcept>
#include <vector>

#include <google/protobuf/descriptor.h>

#include <boost/shared_ptr.hpp>

#include "binary.h"
#include "dynamic_protobuf_manager.h"
#include "logger.h"
#include "protobuf_cpp_type_helpers.h"
#include "exception.h"
#include "field_codec.h"
#include "field_codec_fixed.h"

#include "codecs2/field_codec_default_message.h"
#include "codecs3/field_codec_default_message.h"
#include "type_helper.h"
#include "field_codec_manager.h"
 
/// Objects pertaining to acoustic communications (acomms)
namespace dccl
{
    class FieldCodec;
  
    /// \class Codec dccl/dccl.h dccl/dccl.h
    /// \brief provides an API to the Dynamic CCL Codec.
    /// \ingroup acomms_api
    /// \ingroup dccl_api
    /// \sa acomms_dccl.proto and acomms_modem_message.proto for definition of Google Protocol Buffers messages (namespace dccl::protobuf).
    ///
    /// Simple usage example:
    /// 1. Define a Google Protobuf message with DCCL extensions:
    /// \verbinclude simple.proto
    /// 2. Write a bit of code like this:
    /// \code
    /// dccl::Codec* dccl = dccl::Codec::get();
    /// dccl->load<Simple>();
    /// Simple message_out;
    /// message_out.set_telegram("Hello!");
    /// std::string bytes;
    /// dccl->encode(&bytes, message);
    /// \\ send bytes across some network
    /// Simple message_in;
    /// dccl->decode(bytes&, message_in);
    /// \endcode
    /// \example acomms/chat/chat.cpp
    /// \example acomms/dccl/dccl_simple/dccl_simple.cpp
    /// simple.proto
    /// \verbinclude simple.proto
    /// dccl_simple.cpp
    /// \example acomms/dccl/two_message/two_message.cpp
    /// two_message.proto
    /// \verbinclude two_message.proto
    /// two_message.cpp
    class Codec
    {
      public:       
        Codec(const std::string& dccl_id_codec = default_id_codec_name());
        virtual ~Codec()
        {
            for(std::vector<void *>::iterator it = dl_handles_.begin(),
                    n = dl_handles_.end(); it != n; ++it)
                dlclose(*it);
        }

        /// \brief Load any codecs present in the given shared library handle
        ///
        /// Codecs must be loaded within the shared library using a C function
        /// (declared extern "C") called "dccl3_load" with the signature
        /// void dccl3_load(dccl::Codec* codec)
        void load_library(void* dl_handle);

        /// \brief Load any codecs present in the given shared library handle
        ///
        /// Codecs must be loaded within the shared library using a C function
        /// (declared extern "C") called "dccl3_load" with the signature
        /// void dccl3_load(dccl::Codec* codec)
        void load_library(const std::string& library_path);
        
        /// \brief All messages must be explicited loaded and validated (size checks, option extensions checks, etc.) before they can be encoded/decoded. Use this form when the messages used are static (known at compile time).
        ///
        /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
        /// \throw dccl::Exception if message is invalid. Warnings and errors are written to dccl::dlog.
        template<typename ProtobufMessage>
            void load()
        { load(ProtobufMessage::descriptor()); }

        /// \brief An alterative form for loading and validating messages for message types <i>not</i> known at compile-time ("dynamic").
        ///
        /// \param desc The Google Protobuf "Descriptor" (meta-data) of the message to validate.
        /// \throw dccl::Exception if message is invalid.
        void load(const google::protobuf::Descriptor* desc);

        void set_crypto_passphrase(const std::string& passphrase,
                                   const std::set<unsigned>& do_not_encrypt_ids_ = std::set<unsigned>());
            
        //@}
            
        /// \name Informational Methods.
        ///
        /// Provides various forms of information about the Codec
        //@{

        /// \brief Writes a human readable summary (including field sizes) of the provided DCCL type to the stream provided.
        ///
        /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
        /// \param os Pointer to a stream to write this information (if 0, written to dccl::dlog)
        template<typename ProtobufMessage>
            void info(std::ostream* os = 0) const
        { info(ProtobufMessage::descriptor(), os); }

        /// \brief An alterative form for getting information for messages for message types <i>not</i> known at compile-time ("dynamic").
        ///
        /// \param os Pointer to a stream to write this information (if 0, writes to dccl::dlog)
        void info(const google::protobuf::Descriptor* desc, std::ostream* os = 0) const;

        /// \brief Writes a human readable summary (including field sizes) of all the loaded (validated) DCCL types
        ///
        /// \param os Pointer to a stream to write this information (if 0, writes to dccl::dlog)        
        void info_all(std::ostream* os = 0) const;
            
        /// \brief Gives the DCCL id (defined by the custom message option extension "(dccl.msg).id" in the .proto file). This ID is used on the wire to unique identify incoming message types.
        ///
        /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
        template <typename ProtobufMessage>
            unsigned id() const
        { return id(ProtobufMessage::descriptor()); }            

        /// \brief Get the DCCL ID of an unknown encoded DCCL message.
        /// 
        /// You can use this method along with id() to handle multiple types of known (static) incoming DCCL messages. For example:
        /// \code
        /// unsigned dccl_id = codec->id_from_encoded(bytes);    
        /// if(dccl_id == codec->id<MyProtobufType1>())
        /// {
        ///     MyProtobufType1 msg_out1;
        ///     codec->decode(bytes, &msg_out1);
        /// }
        /// else if(dccl_id == codec->id<MyProtobufType2>())
        /// {
        ///     MyProtobufType2 msg_out2;
        ///     codec->decode(bytes, &msg_out2);
        /// }
        /// \endcode
        /// \param bytes encoded message to get the DCCL ID of
        /// \return DCCL ID
        /// \sa test/acomms/dccl8/test.cpp and test/acomms/dccl8/test.proto
        unsigned id(const std::string& bytes);

        /// \brief Provides the DCCL ID given a DCCL type.
        unsigned id(const google::protobuf::Descriptor* desc) const {
            return desc->options().GetExtension(dccl::msg).id();
        }            

        //@}
            
        /// \brief Provides the encoded size (in bytes) of msg. This is useful if you need to know the size of a message before encoding it (encoding it is generally much more expensive than calling this method)
        ///
        /// \param msg Google Protobuf message with DCCL extensions for which the encoded size is requested
        /// \return Encoded (using DCCL) size in bytes
        unsigned size(const google::protobuf::Message& msg);
            
        //@}
       
        /// \name Codec functions.
        ///
        /// This is where the real work happens.
        //@{

        /// \brief Encodes a DCCL message
        ///
        /// \param bytes Pointer to byte string to store encoded msg
        /// \param msg Message to encode (must already have been validated)
        /// \param header_only If true, only decode the header (do not try to decrypt (if applicable) and decode the message body)
        /// \throw Exception if message cannot be encoded.
        void encode(std::string* bytes, const google::protobuf::Message& msg, bool header_only = false);
            
        /// \brief Decode a DCCL message when the type is known at compile time.
        ///
        /// \param bytes encoded message to decode (must already have been validated)
        /// \param msg Pointer to any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message). The decoded message will be written here.
        /// \param header_only If true, only decode the header (do not try to decrypt (if applicable) and decode the message body)
        /// \throw Exception if message cannot be decoded.
        void decode(const std::string& bytes, google::protobuf::Message* msg, bool header_only = false);

        /// \brief Decode a DCCL message when the type is known at compile time.
        ///
        /// \param bytes encoded message to decode (must already have been validated) which will have the used bytes stripped from the front of the encoded message
        /// \param msg Pointer to any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message). The decoded message will be written here.
        /// \throw Exception if message cannot be decoded.
        void decode(std::string* bytes, google::protobuf::Message* msg);

        /// \brief An alterative form for decoding messages for message types <i>not</i> known at compile-time ("dynamic").
        ///
        /// \tparam GoogleProtobufMessagePointer anything that acts like a pointer (has operator*) to a google::protobuf::Message (smart pointers like boost::shared_ptr included)
        /// \param bytes the byte string returned by encode
        /// \param header_only If true, only decode the header (do not try to decrypt (if applicable) and decode the message body)
        /// \throw Exception if message cannot be decoded
        /// \return pointer to decoded message (a google::protobuf::Message). You are responsible for deleting the memory used by this pointer, so we recommend using a smart pointer here (e.g. boost::shared_ptr or the C++11 equivalent). This message can be examined using the Google Reflection/Descriptor API.
        template<typename GoogleProtobufMessagePointer>
            GoogleProtobufMessagePointer decode(const std::string& bytes, bool header_only = false);
        
        /// \brief An alterative form for decoding messages for message types <i>not</i> known at compile-time ("dynamic"), where the bytes used are stripped from the front of the encoded message.
        ///
        /// \tparam GoogleProtobufMessagePointer anything that acts like a pointer (has operator*) to a google::protobuf::Message (smart pointers like boost::shared_ptr included)
        /// \param bytes encoded message to decode (must already have been validated) which will have the used bytes stripped from the front of the encoded message
        /// \throw Exception if message cannot be decoded
        /// \return pointer to decoded message (a google::protobuf::Message). You are responsible for deleting the memory used by this pointer, so we recommend using a smart pointer here (e.g. boost::shared_ptr or the C++11 equivalent). This message can be examined using the Google Reflection/Descriptor API.
        template<typename GoogleProtobufMessagePointer>
            GoogleProtobufMessagePointer decode(std::string* bytes);
      
        static std::string default_id_codec_name()
        { return "dccl.default.id"; }        

        
        static std::string default_codec_name(int version = 2)
        {
            switch(version)
            {
                case 2:
                    return dccl::DCCLFieldOptions::descriptor()->FindFieldByName("codec")->default_value_string();
                default:
                    return "dccl.default" + boost::lexical_cast<std::string>(version);
            }
            
        }

        
        friend class v2::DefaultMessageCodec;
        //friend class v3::DefaultMessageCodec;
      private:
        Codec(const Codec&);
        Codec& operator= (const Codec&);

        void encrypt(std::string* s, const std::string& nonce);
        void decrypt(std::string* s, const std::string& nonce);

        void set_default_codecs();

        boost::shared_ptr<FieldCodecBase> id_codec() const
        {
            return FieldCodecManager::find(google::protobuf::FieldDescriptor::TYPE_UINT32,
                                           id_codec_);
        }
        
      private:
        // SHA256 hash of the crypto passphrase
        std::string crypto_key_;

	// set of DCCL IDs *not* to encrypt        
	std::set<unsigned> skip_crypto_ids_;

        // maps `dccl.id`s onto Message Descriptors
        std::map<int32, const google::protobuf::Descriptor*> id2desc_;
        std::string id_codec_;

        std::vector<void *> dl_handles_;
        
    };

    inline std::ostream& operator<<(std::ostream& os, const Codec& codec)
    {
        codec.info_all(&os);
        return os;
    }
}

template<typename GoogleProtobufMessagePointer>
GoogleProtobufMessagePointer dccl::Codec::decode(const std::string& bytes, bool header_only /* = false */)
{
    unsigned this_id = id(bytes);   

    if(!id2desc_.count(this_id))
        throw(Exception("Message id " + boost::lexical_cast<std::string>(this_id) + " has not been loaded. Call load() before decoding this type."));
                    
    // ownership of this object goes to the caller of decode()
    GoogleProtobufMessagePointer msg =
        dccl::DynamicProtobufManager::new_protobuf_message<GoogleProtobufMessagePointer>(id2desc_.find(this_id)->second);
    decode(bytes, &(*msg), header_only);
    return msg;
}

template<typename GoogleProtobufMessagePointer>
GoogleProtobufMessagePointer dccl::Codec::decode(std::string* bytes)
{
    GoogleProtobufMessagePointer msg = 
        decode<GoogleProtobufMessagePointer>(*bytes);
    
    unsigned last_size = size(*msg);
    bytes->erase(0, last_size);
    
    return msg;
}

#endif
